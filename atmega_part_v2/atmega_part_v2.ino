//второй вариант кода для atmega8a. здесь цикл измерений построен на постоянном последовательном опросе пинов
//без использования прерываний
//прерывание только для установки флага on для начала передачи данных
//ногу 1 прерывания подтянуть к питанию 10к

#define pin_pwm1 5  //пины входов pwm вентов
#define pin_pwm2 6
#define pin_pwm3 7
#define tau 1000     //базовый период измерения. кратно секунде, чтобы потом не париться с расчетами, но можно любой

unsigned int rpm1 = 0, rpm2 = 0, rpm3 = 0; //передаваемые значения rpm вентов
unsigned int clk1, clk2, clk3;    //значение счетчиков вентов
boolean flag1, flag2, flag3;      //флаги предыдущего состояния пинов
boolean on = false;               //флаг начала transmite
unsigned long tau_c;              //вспомогательная переменная времени

void setup() {
  Serial.begin(9600);                     //иницилизируем аппаратный serial для atmega8a (софтовый отсутствует как класс)
  attachInterrupt(0, transmite, RISING);  //прикручиваем прерывание начала передачи данных по serial
  pinMode(pin_pwm1, INPUT);               //готовим ноги атмеги
  pinMode(pin_pwm2, INPUT);
  pinMode(pin_pwm2, INPUT);
  pinMode(3,OUTPUT);
}

void loop() {
//  Serial.print(on);
  if (on) {               //получен on по прерыванию, начинаем передачу данных.
    Serial.print(rpm1);   //есть вероятность, что будет работать не так как надо, так как по прерыванию флаг on
    Serial.print(",");    //может быть получен (и скорее всего будет так) во время цикла измерений
    Serial.print(rpm2);   //тогда чем tau меньше, тем лучше, дабы не заставлять основной мк ждать слишком долго.
    Serial.print(",");    //зато получаем максимально свежие данные rpm вентов. tau нет смысла делать меньше чем
    Serial.print(rpm3);   //время выполнения основного цикла на первом мк.
    Serial.print("."); 
    
   //если работать будет некорректно - тогда засовываем все в обработчик прерывания
    on=false;
  }                       //хотя так в теории работать не должно (но работает в первом варианте кода)
  
  flag1 = false;        //флаги предыдущего состояния, перед циклом измерения сбрасываем
  flag2 = false;
  flag3 = false;
  clk1=0;
  clk2=0;
  clk3=0;
  tau_c = millis();
  while ((millis() - tau_c) <= tau) {       //цикл измерения
    if (digitalRead(pin_pwm1) == HIGH) {
      flag1 = true;                         //флаг предыдущего состояния порта, запоминаем что был HIGH;
    } else if (flag1) {                     //первое вхождение в LOW - точка отсчета clk
      flag1 = false;                        //запоминаем что стал LOW
      clk1++;                               //счетчик clk++
    }

    if (digitalRead(pin_pwm2) == HIGH) {
      flag2 = true;                         //флаг предыдущего состояния порта, запоминаем что был HIGH;
    } else if (flag2) {                     //первое вхождение в LOW - точка отсчета clk
      flag2 = false;                        //запоминаем что стал LOW
      clk2++;                               //счетчик clk++
    }

    if (digitalRead(pin_pwm3) == HIGH) {
      flag3 = true;                         //флаг предыдущего состояния порта, запоминаем что был HIGH;
    } else if (flag3) {                     //первое вхождение в LOW - точка отсчета clk
      flag3 = false;                        //запоминаем что стал LOW
      clk3++;                               //счетчик clk++
    }
  }
  rpm1 = clk1;                         //в вентах дважды за оборот считается rpm
  rpm2 = clk2;                         //камент выше неактуален - передаем raw данные, без обработки расчетом
  rpm3 = clk3;
}
void transmite() {
  on = true;                      //устанавливаем флаг начала передачи данных
}
